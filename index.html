<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XY Oscilloscope Audio Visualizer</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #111;
            color: #fff;
        }
        canvas {
            border: 1px solid #fff;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            align-items: center;
        }
        .controls label {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <h1>XY Oscilloscope Audio Visualizer</h1>
    <div class="controls">
        <label for="samplingTime">Sampling Time:</label>
        <input type="range" id="samplingTime" min="256" max="32768" step="256" value="2048">
        <span id="samplingValue">2048</span>
    </div>
    <input type="file" id="audioUpload" accept="audio/*">
    <canvas id="oscilloscope" width="500" height="500"></canvas>

    <script>
        const audioUpload = document.getElementById('audioUpload');
        const samplingTimeSlider = document.getElementById('samplingTime');
        const samplingValueDisplay = document.getElementById('samplingValue');
        const canvas = document.getElementById('oscilloscope');
        const ctx = canvas.getContext('2d');
        let audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let currentSource = null;
        let analyserX = null;
        let analyserY = null;

        samplingTimeSlider.addEventListener('input', function() {
            const fftSize = parseInt(samplingTimeSlider.value);
            samplingValueDisplay.textContent = fftSize;

            if (analyserX && analyserY) {
                analyserX.fftSize = fftSize;
                analyserY.fftSize = fftSize;
            }
        });

        audioUpload.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                if (currentSource) {
                    currentSource.stop(); // Stop the previous audio
                    currentSource = null;
                }
                const reader = new FileReader();

                reader.onload = function(e) {
                    audioContext.decodeAudioData(e.target.result, function(buffer) {
                        visualize(buffer);
                    });
                };

                reader.readAsArrayBuffer(file);
            }
        });

        function visualize(buffer) {
            const source = audioContext.createBufferSource();
            source.buffer = buffer;

            const splitter = audioContext.createChannelSplitter(2);
            analyserX = audioContext.createAnalyser();
            analyserY = audioContext.createAnalyser();
            
            const fftSize = parseInt(samplingTimeSlider.value);
            analyserX.fftSize = fftSize;
            analyserY.fftSize = fftSize;

            source.connect(splitter);
            splitter.connect(analyserX, 0); // Left channel -> X axis
            splitter.connect(analyserY, 1); // Right channel -> Y axis

            // Connect the source to the speakers
            source.connect(audioContext.destination);
            source.start();

            currentSource = source; // Keep track of the current source

            function draw() {
                const bufferLengthX = analyserX.fftSize;
                const bufferLengthY = analyserY.fftSize;
                const dataArrayX = new Float32Array(bufferLengthX);
                const dataArrayY = new Float32Array(bufferLengthY);

                analyserX.getFloatTimeDomainData(dataArrayX);
                analyserY.getFloatTimeDomainData(dataArrayY);

                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.lineWidth = 2;
                ctx.strokeStyle = 'lime';
                ctx.beginPath();

                for (let i = 0; i < bufferLengthX; i++) {
                    const x = (dataArrayX[i] + 1) * (canvas.width / 2);  
                    const y = canvas.height - (dataArrayY[i] + 1) * (canvas.height / 2); // Invert y-axis
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                requestAnimationFrame(draw);
            }

            draw();
        }
    </script>
</body>
</html>
